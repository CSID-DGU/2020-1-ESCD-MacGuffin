{"ast":null,"code":"/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\nmodule.exports = function proxyPolyfill() {\n  let lastRevokeFn = null;\n  let ProxyPolyfill;\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n\n  function isObject(o) {\n    return o ? typeof o === 'object' || typeof o === 'function' : false;\n  }\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n\n\n  ProxyPolyfill = function (target, handler) {\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    } // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n\n\n    let throwRevoked = function () {};\n\n    lastRevokeFn = function () {\n      /** @suppress {checkTypes} */\n      target = null; // clear ref\n\n      throwRevoked = function (trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n\n    setTimeout(function () {\n      lastRevokeFn = null;\n    }, 0); // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n\n    const unsafeHandler = handler;\n    handler = {\n      'get': null,\n      'set': null,\n      'apply': null,\n      'construct': null\n    };\n\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n\n      handler[k] = unsafeHandler[k];\n    }\n\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    } // Define proxy as this, or a Function (if either it's callable, or apply is set).\n    // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n\n\n    let proxy = this;\n    let isMethod = false;\n    let isArray = false;\n\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        const usingNew = this && this.constructor === proxy;\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        } // since the target was a function, fallback to calling it directly.\n\n\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target); // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n\n          const f =\n          /** @type {!Function} */\n          target.bind.apply(target, args);\n          return new f();\n        }\n\n        return target.apply(this, args);\n      };\n\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    } // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n\n\n    const getter = handler.get ? function (prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function (prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    const setter = handler.set ? function (prop, value) {\n      throwRevoked('set');\n      const status = handler.set(this, prop, value, proxy); // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n      // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n      // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function (prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    }; // Clone direct properties (i.e., not part of a prototype).\n\n    const propertyNames = Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function (prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return; // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n\n      const real = Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: !!real.enumerable,\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop)\n      };\n      Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    }); // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n\n    let prototypeOk = true;\n\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(proxy, Object.getPrototypeOf(target));\n    } else if (proxy.__proto__) {\n      proxy.__proto__ = target.__proto__;\n    } else {\n      prototypeOk = false;\n    }\n\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n\n        Object.defineProperty(proxy, k, {\n          get: getter.bind(target, k)\n        });\n      }\n    } // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n\n\n    Object.seal(target);\n    Object.seal(proxy);\n    return proxy; // nb. if isMethod is true, proxy != this\n  };\n\n  ProxyPolyfill.revocable = function (target, handler) {\n    const p = new ProxyPolyfill(target, handler);\n    return {\n      'proxy': p,\n      'revoke': lastRevokeFn\n    };\n  };\n\n  return ProxyPolyfill;\n};","map":{"version":3,"sources":["C:/Users/BumSu Park/React/macguffin/node_modules/proxy-polyfill/src/proxy.js"],"names":["module","exports","proxyPolyfill","lastRevokeFn","ProxyPolyfill","isObject","o","target","handler","TypeError","throwRevoked","trap","setTimeout","unsafeHandler","k","apply","bind","proxy","isMethod","isArray","usingNew","constructor","args","Array","prototype","slice","call","arguments","unshift","f","getter","get","prop","setter","set","value","status","propertyNames","Object","getOwnPropertyNames","propertyMap","forEach","real","getOwnPropertyDescriptor","desc","enumerable","defineProperty","prototypeOk","setPrototypeOf","getPrototypeOf","__proto__","seal","revocable","p"],"mappings":"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","sourcesContent":["/*\n * Copyright 2016 Google Inc. All rights reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\n\nmodule.exports = function proxyPolyfill() {\n  let lastRevokeFn = null;\n  let ProxyPolyfill;\n\n  /**\n   * @param {*} o\n   * @return {boolean} whether this is probably a (non-null) Object\n   */\n  function isObject(o) {\n    return o ? (typeof o === 'object' || typeof o === 'function') : false;\n  }\n\n  /**\n   * @constructor\n   * @param {!Object} target\n   * @param {{apply, construct, get, set}} handler\n   */\n  ProxyPolyfill = function(target, handler) {\n    if (!isObject(target) || !isObject(handler)) {\n      throw new TypeError('Cannot create proxy with a non-object as target or handler');\n    }\n\n    // Construct revoke function, and set lastRevokeFn so that Proxy.revocable can steal it.\n    // The caller might get the wrong revoke function if a user replaces or wraps scope.Proxy\n    // to call itself, but that seems unlikely especially when using the polyfill.\n    let throwRevoked = function() {};\n    lastRevokeFn = function() {\n      /** @suppress {checkTypes} */\n      target = null;  // clear ref\n      throwRevoked = function(trap) {\n        throw new TypeError(`Cannot perform '${trap}' on a proxy that has been revoked`);\n      };\n    };\n    setTimeout(function() {\n      lastRevokeFn = null;\n    }, 0);\n\n    // Fail on unsupported traps: Chrome doesn't do this, but ensure that users of the polyfill\n    // are a bit more careful. Copy the internal parts of handler to prevent user changes.\n    const unsafeHandler = handler;\n    handler = { 'get': null, 'set': null, 'apply': null, 'construct': null };\n    for (let k in unsafeHandler) {\n      if (!(k in handler)) {\n        throw new TypeError(`Proxy polyfill does not support trap '${k}'`);\n      }\n      handler[k] = unsafeHandler[k];\n    }\n    if (typeof unsafeHandler === 'function') {\n      // Allow handler to be a function (which has an 'apply' method). This matches what is\n      // probably a bug in native versions. It treats the apply call as a trap to be configured.\n      handler.apply = unsafeHandler.apply.bind(unsafeHandler);\n    }\n\n    // Define proxy as this, or a Function (if either it's callable, or apply is set).\n    // TODO(samthor): Closure compiler doesn't know about 'construct', attempts to rename it.\n    let proxy = this;\n    let isMethod = false;\n    let isArray = false;\n    if (typeof target === 'function') {\n      proxy = function ProxyPolyfill() {\n        const usingNew = (this && this.constructor === proxy);\n        const args = Array.prototype.slice.call(arguments);\n        throwRevoked(usingNew ? 'construct' : 'apply');\n\n        if (usingNew && handler['construct']) {\n          return handler['construct'].call(this, target, args);\n        } else if (!usingNew && handler.apply) {\n          return handler['apply'](target, this, args);\n        }\n\n        // since the target was a function, fallback to calling it directly.\n        if (usingNew) {\n          // inspired by answers to https://stackoverflow.com/q/1606797\n          args.unshift(target);  // pass class as first arg to constructor, although irrelevant\n          // nb. cast to convince Closure compiler that this is a constructor\n          const f = /** @type {!Function} */ (target.bind.apply(target, args));\n          return new f();\n        }\n        return target.apply(this, args);\n      };\n      isMethod = true;\n    } else if (target instanceof Array) {\n      proxy = [];\n      isArray = true;\n    }\n\n    // Create default getters/setters. Create different code paths as handler.get/handler.set can't\n    // change after creation.\n    const getter = handler.get ? function(prop) {\n      throwRevoked('get');\n      return handler.get(this, prop, proxy);\n    } : function(prop) {\n      throwRevoked('get');\n      return this[prop];\n    };\n    const setter = handler.set ? function(prop, value) {\n      throwRevoked('set');\n      const status = handler.set(this, prop, value, proxy);\n      // TODO(samthor): If the calling code is in strict mode, throw TypeError.\n      // if (!status) {\n        // It's (sometimes) possible to work this out, if this code isn't strict- try to load the\n        // callee, and if it's available, that code is non-strict. However, this isn't exhaustive.\n      // }\n    } : function(prop, value) {\n      throwRevoked('set');\n      this[prop] = value;\n    };\n\n    // Clone direct properties (i.e., not part of a prototype).\n    const propertyNames = Object.getOwnPropertyNames(target);\n    const propertyMap = {};\n    propertyNames.forEach(function(prop) {\n      if ((isMethod || isArray) && prop in proxy) {\n        return;  // ignore properties already here, e.g. 'bind', 'prototype' etc\n      }\n      const real = Object.getOwnPropertyDescriptor(target, prop);\n      const desc = {\n        enumerable: !!real.enumerable,\n        get: getter.bind(target, prop),\n        set: setter.bind(target, prop),\n      };\n      Object.defineProperty(proxy, prop, desc);\n      propertyMap[prop] = true;\n    });\n\n    // Set the prototype, or clone all prototype methods (always required if a getter is provided).\n    // TODO(samthor): We don't allow prototype methods to be set. It's (even more) awkward.\n    // An alternative here would be to _just_ clone methods to keep behavior consistent.\n    let prototypeOk = true;\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(proxy, Object.getPrototypeOf(target));\n    } else if (proxy.__proto__) {\n      proxy.__proto__ = target.__proto__;\n    } else {\n      prototypeOk = false;\n    }\n    if (handler.get || !prototypeOk) {\n      for (let k in target) {\n        if (propertyMap[k]) {\n          continue;\n        }\n        Object.defineProperty(proxy, k, { get: getter.bind(target, k) });\n      }\n    }\n\n    // The Proxy polyfill cannot handle adding new properties. Seal the target and proxy.\n    Object.seal(target);\n    Object.seal(proxy);\n\n    return proxy;  // nb. if isMethod is true, proxy != this\n  };\n\n  ProxyPolyfill.revocable = function(target, handler) {\n    const p = new ProxyPolyfill(target, handler);\n    return { 'proxy': p, 'revoke': lastRevokeFn };\n  };\n\n  return ProxyPolyfill;\n}"]},"metadata":{},"sourceType":"script"}